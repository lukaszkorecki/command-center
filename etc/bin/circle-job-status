#!/usr/bin/env bash

if [[ -z "$CIRCLECI_CLI_TOKEN" ]] ; then
  echo "CIRCLECI_CLI_TOKEN is not set"
  exit 1
fi

if [[ -z $(which jq) ]] ; then
  echo "jq is not installed"
  exit 1
fi

if [[ -z $(which curl) ]] ; then
  echo "curl is not installed"
  exit 1
fi

set -euo pipefail


# Command line flags
rootDir=
currentBranch=
openInBrowser=

while getopts "ohb:r:" opt; do
  case ${opt} in
    b ) ## branch, default current
      currentBranch=$OPTARG
      ;;
    r ) ## root dir, default current
      rootDir=$OPTARG
      ;;
    o ) ## open in browser, requires circleci CLI to be installed
      openInBrowser=true
      [[ -z "$(which circleci)" ]] && echo "circleci CLI is not installed" && exit 1
      ;;
    h )
      echo "Usage: $(dirname $0)"
      echo "! Must run in a project root !"
      echo "optional flags:"
      grep ') ##' $0 | grep -v grep | sed 's/) ##/-/'
      exit 1
      ;;
  esac
done

if [[  ! -z "$rootDir" ]] ; then
  cd $rootDir
fi

# extract <repo> from git@github.com:<org>/<repo>.git
mostLikelyProjectName=$(basename -s .git  $(git remote get-url origin))

# extract <org> from git@github.com:<org>/<repo>.git
mostlikelyOrg=$(basename $(dirname $(git remote get-url origin)) | cut -d: -f2)

if [[ -z "${currentBranch}" ]] ; then
  currentBranch=$(git rev-parse --abbrev-ref HEAD)
fi

slug="gh/${mostlikelyOrg}/${mostLikelyProjectName}"


red() {
  echo -e "\033[0;31m$1\033[0m"
}

greeen() {
  echo -e "\033[0;32m$1\033[0m"
}

yellow() {
  echo -e "\033[0;33m$1\033[0m"
}

bold() {
  echo -e "\033[1m$1\033[0m"
}

apiRequest() {
  method=$1
  shift
  url=$1
  shift
  curl -q --silent \
     -H "Circle-Token: $CIRCLECI_CLI_TOKEN" \
      -X ${method} \
     --json ''\
     --url "${url}"
}

verifyToken() {
  apiRequest "GET" 'https://circleci.com/api/v2/me' | jq -r .login
}


getSecondsFromTS() {
  ts="${1}"
  date -j -f "%Y-%m-%dT%T" $(echo $ts | cut -d. -f 1) "+%s"
}

secondsToHumanReadable() {
  seconds=$1
  # print days, hrs, minutes
  printf "%02dd %02dh %02dm\n" $(($seconds/86400)) $(($seconds%86400/3600)) $(($seconds%3600/60))

}

getStatusOfLastWorkflowForBranch() {
  local branch=$1

  echo -e "Checking $(bold ${slug}) on $(bold ${branch})\n"
  # XXX: we only get the first workflow, what should we do if there are multiple?
  workflowName=$(apiRequest GET "https://circleci.com/api/v2/insights/pages/${slug}/summary?branches=${branch}&reporting-window=last-7-days" | jq -r ".all_workflows.[0]")
  workflowRuns=$(apiRequest GET "https://circleci.com/api/v2/insights/${slug}/workflows/${workflowName}?branch=${branch}")

  lastWorkflowId=$(echo "${workflowRuns}" | jq -r '.items[0].id')
  lastWorkflowDuration=$(echo "${workflowRuns}" | jq -r '.items[0].duration')
  lastWorkflowDate=$(echo "${workflowRuns}" | jq -r '.items[0].stopped_at')


  diffSeconds=$(secondsToHumanReadable $(($(TZ=UTC date +%s) - $(TZ=UTC getSecondsFromTS "${lastWorkflowDate}"))))
  jobs=$(apiRequest GET "https://circleci.com/api/v2/workflow/${lastWorkflowId}/job")

  echo "$(bold ${workflowName})"
  echo "${diffSeconds} ago, took ${lastWorkflowDuration}s"
  names=$(echo "${jobs}" | jq -r '.items|map(.name+"\n")|.[]')
  statuses=$(echo "${jobs}" | jq -r '.items|map(.status+"\n")|.[]')

  # create arrays of job names and statuses
  namesArray=($names)
  statusesArray=($statuses)

  # iterate over the job names and statuses and print them
  for i in "${!namesArray[@]}"; do
    name=${namesArray[$i]}
    status=${statusesArray[$i]}

    statusString=""

    case $status in
      "success")
        statusString=$(greeen $status)
        ;;
      "failed")
        statusString=$(red $status)
        ;;
      "error")
        statusString=$(red $status)
        ;;
      "canceled")
        statusString=$(yellow $status)
        ;;
      "unauthorized")
        statusString=$(red $status)
        ;;
      *)
        statusString="${status}"
        ;;
    esac

    # with nice padding
    printf "%-40s %s\n" "$name" "$statusString"

  done

}

getStatusOfLastWorkflowForBranch "${currentBranch}"

if [[ ! -z "$openInBrowser" ]] ; then
  circleci open
fi
